TO DO

Change term carriedOverBalance Deferred amount:
    The amounts that wont be adressed on this billing date but on later ones

getNextCycle() resolves end for variant 0

Must define what to do with the height of each cycle container
Make a table with scroll

Transaction container:

	ADD button function:
		-validate data
		if valid data:
			-fetch data
			if valid request:
				-close form container
				-make sure that all inputs get back to their default values
				-add new transaction to Transaction Container
			else:
				maybe display the error somewhere, but it would be better to ensure the 
				request success by validating the data properly.
		else:
			display errors and keep input values

		Note: every time a new transaction is added several containers will get another 
		item

General things I don't know where to put

	The fucking function:
		This madafaka starts by taking an array of transactions (maybe just the selected 
		ones in our Transaction container instead of all of them)

		Then, it must get an object that aligns, conforms, and matches the interface 
		OutlookInterface.

		Finally, it passes the object to the Outlook component.
	
	getInterestsToPay(transaction):
		this one will calculate the interests for a specific transaction.
		divide amount by installments, itereate through each cycle and return
		the insterests. the remainingCapital must be 0 at the end.


----------------------------------------------------------------------------------------
GET INTERESTS TO PAY

Calculate interests from the purchase date.

Divide the amount by the number of installments.

for i in installments:
	calculate month interests





Things I need to calculate interests:

	number of days from transactionDate or new cycle start to the next billing date


interface Cycle {
	dueDate: Date,
	start: Date,
	end: Date,
	billingDate: Date,
	variant: 0 | 1
}

let currentCycle: Cycle = {
	dueDate: new Date(),
	start: new Date(),
	end: new Date(),
	billingDate: new Date(),
	variant: 0
}

function getNextCycle(currentCycle) {
	if (!!currentCycle.variant) {
		let dueDate = currentCycle.dueDate.
		let start
		let end
		let billingDate
	}
}

dayjs('2019-01-25').daysInMonth() // 31



start 1,
end 30
dueDate end + 17

start 15,
end 14
dueDate end + 1






































		

NOTES

Making the Balance table thinner make the columns look more aligned and better.


SUGGESTIONS

Total bar should have: 
-endDate: when the debt would get paid in full.
-maybe totalMonths or n/of based on the current date:

Page or section to see details about a Transaction, such as the amount to pay each 
month for that specific transaction. That is, amount / installments + monthInterests.








--------------------------------------- REDUX ---------------------------------------

INSTALLATION

npm init -y

npm install @reduxjs/toolkit

npm install react-redux


SETUP

public
src
	app
		store.js
	features
		counter
			counter.js
			counterSlice.js
			counterAPI.js
		anotherStateFeature
			thatThing.js
			thatThingSlice.js


CREATE A STORE

Pass in an object with the reducer property to the configureStore function. This object 
will contain all the values we want to be stored as property keys, and the value to each
property will be the reducer function that will handel the changes of each value.


export const store = configureStore({
	reducer: {
		counter: counterReducer,
		nameInput: nameInputReducer
	}
})

By doing so we will be able to use state.counter and state.nameInput.


ACCESS DATA FROM THE STORE

const inputValue = useSelector((state) => state.form.amount);


ACCESS REDUCER

const dispatch = useDispatch();

dispatch(setAmount(e.target.value));





export interface TransactionBalanceInterface {
    transactionDate: Date | string,
    installments: { n: number, of: number},
    paidCapital: number,
    paidInterests: number,
    remainingCapital: number,
    remainingInterests: number
}

export interface CycleTransactionContainerInterface {
    cycle: number,
    cycleStart: Date | string,
    cycleEnd: Date | string,
    interestRate?: number,
    transactionBalances: Array<TransactionBalanceInterface>
}

export interface SubtotalBarInterface {
    paidCapital: number,
    paidInterests: number,
    remainingCapital: number,
    remainingInterests: number
}

export interface CycleBillInterface {
    dueDate: Date | string,
    interestsFromPrevDebt: number,
    cycleInterests: number,
    addressableAmount: number,
    minimumPayment: number,
    carriedOverBalance: number,
    fullPayment: number
}

interface CycleInterface extends 
CycleTransactionContainerInterface,
SubtotalBarInterface,
CycleBillInterface {};

export interface CycleContainerInterface {
    cycles: Array<CycleInterface>
};


How would CycleContainerInterface look like?